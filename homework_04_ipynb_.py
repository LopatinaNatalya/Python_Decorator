# -*- coding: utf-8 -*-
"""Копия блокнота "homework_04.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LZjMy7zeHalkdqrXz6VRY1WCLc-9eBE3

# Домашнее задание: декораторы

## Импорт библиотек, установка констант
"""

import requests
import time
import re

from random import randint

BOOK_PATH = 'https://www.gutenberg.org/files/2638/2638-0.txt'

"""## Задание 1"""

def benchmark(func):
    """
    Декоратор, выводящий время, которое заняло выполнение декорируемой функции
    """

    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        print(f'Время выполнения функции {func.__name__}: {end_time-start_time}')
        return result

    return wrapper

@benchmark
def word_count(word, url=BOOK_PATH):
    # отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(url).text

    # заменяем в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()

    # считаем
    cnt = len(re.findall(word.lower(), processed_book))

    return f"Cлово {word} встречается {cnt} раз"

print(word_count('whole'))

"""## Задание 2"""

def logging(func):
    """
    Декоратор, который выводит параметры с которыми была вызвана функция
    """

    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print(f'Функция вызвана с параметрами:\n {args}, {kwargs}')
        return result

    return wrapper

@logging
def word_count(word, url=BOOK_PATH):
    # отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(url).text

    # заменяем в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()

    # считаем
    cnt = len(re.findall(word.lower(), processed_book))

    return f"Cлово {word} встречается {cnt} раз"

print(word_count('whole'))

"""## Задание 3"""

def counter(func):
    """
    Декоратор, считающий и выводящий количество вызовов декорируемой функции
    """
    global count
    count = 0
    def wrapper(*args, **kwargs):
        global count
        result = func(*args, **kwargs)
        count += 1
        print('Функция была вызвана:', count, 'раз')
        return result

    return wrapper

@counter
def word_count(word, url=BOOK_PATH):
    # отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(url).text

    # заменяем в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()

    # считаем
    cnt = len(re.findall(word.lower(), processed_book))

    return f"Cлово {word} встречается {cnt} раз"

print(word_count('whole'))
print(word_count('ask'))

"""## Задание 4"""

def memo(func):
    """
    Декоратор, запоминающий результаты исполнения функции func, чьи аргументы args должны быть хешируемыми
    """
    cache = {}

    #@functools.wraps(func)
    def fmemo(*args):
        cache_key = args
        if cache_key not in cache:
            cache[cache_key] = func(*args)
        return cache[cache_key]
    fmemo.cache = cache
    return fmemo

"""## Тестирование"""

@counter
@logging
@benchmark
def word_count(word, url=BOOK_PATH):
    """
    Функция для посчета указанного слова на html-странице
    """

    # отправляем запрос в библиотеку Gutenberg и забираем текст
    raw = requests.get(url).text

    # заменяем в тексте все небуквенные символы на пробелы
    processed_book = re.sub('[\W]+' , ' ', raw).lower()

    # считаем
    cnt = len(re.findall(word.lower(), processed_book))

    return f"Cлово {word} встречается {cnt} раз"

print(word_count('whole'))

def fib(n):
    """
    Вычисление числа Фибоначчи
    """
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# измеряем время выполнения
@benchmark
def fib_nocache(num):
    """
    Вычисление числа Фибоначчи без использования хеширования
    """
    return fib(num)

print(fib_nocache(20))

@memo
def fib(n):
    if n < 2:
        return n
    return fib(n-2) + fib(n-1)

# измеряем время выполнения
@benchmark
def fib_cache(num):
    """
    Вычисление числа Фибоначчи с использованием хеширования
    """
    return fib(num)

print(fib_cache(20))